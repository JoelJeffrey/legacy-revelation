{
  "name": "backbone.radio",
  "description": "Messaging patterns for Backbone applications.",
  "homepage": "https://github.com/marionettejs/backbone.radio",
  "version": "0.8.5",
  "main": "build/backbone.radio.js",
  "keywords": [
    "backbone",
    "marionette",
    "decoupled",
    "pubsub",
    "publish",
    "subscribe",
    "messaging",
    "architecture",
    "spa"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/marionettejs/backbone.radio/blob/master/LICENSE"
    }
  ],
  "scripts": {
    "test": "grunt",
    "coverage": "grunt coverage"
  },
  "author": {
    "name": "Jmeas",
    "email": "jellyes2@gmail.com",
    "url": "http://jmeas.com"
  },
  "bugs": {
    "url": "https://github.com/marionettejs/backbone.radio/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/marionettejs/backbone.radio.git"
  },
  "github": "https://github.com/marionettejs/backbone.radio",
  "dependencies": {
    "backbone": "1.0.0 - 1.1.2",
    "underscore": "1.4.4 - 1.7.0"
  },
  "devDependencies": {
    "chai": "^1.9.1",
    "grunt": "~0.4.5",
    "grunt-contrib-concat": "^0.4.0",
    "grunt-contrib-jshint": "^0.10.0",
    "grunt-contrib-uglify": "^0.4.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-coveralls": "^0.3.0",
    "grunt-env": "^0.4.1",
    "grunt-istanbul": "^0.3.0",
    "grunt-mocha-test": "^0.11.0",
    "grunt-preprocess": "4.0.0",
    "grunt-template": "^0.2.3",
    "load-grunt-tasks": "^0.4.0",
    "mocha": "^1.20.1",
    "sinon": "^1.10.2",
    "sinon-chai": "^2.5.0"
  },
  "readme": "# Backbone.Radio\n\n[![Travis Build Status](http://img.shields.io/travis/marionettejs/backbone.radio.svg?style=flat)](https://travis-ci.org/marionettejs/backbone.radio)\n[![Coverage Status](https://img.shields.io/coveralls/marionettejs/backbone.radio.svg?style=flat)](https://coveralls.io/r/marionettejs/backbone.radio)\n[![Gitter chat room](https://img.shields.io/badge/gitter-backbone.radio-brightgreen.svg?style=flat)](https://gitter.im/marionettejs/backbone.radio)\n\nUse Backbone.Radio to build large, maintainable, and decoupled applications.\n\nBackbone.Radio is a collection of messaging patterns for Backbone applications. It uses Backbone.Events as a\npub-sub message bus, then adds semantics to your communications through the addition of two new messaging\npatterns, Commands and Requests. The three systems are bound together as Channels, which provide explicit\nnamespacing to your communications.\n\n## Installation\n\nClone this repository or install via [Bower](http://bower.io/) or [npm](https://www.npmjs.org/).\n\n```\nbower install backbone.radio\nnpm install backbone.radio\n```\n\n## Documentation\n\n- [Getting Started](#getting-started)\n  - [Backbone.Events](#backboneevents)\n  - [Radio.Commands](#backboneradiocommands)\n  - [Radio.Requests](#backboneradiorequests)\n  - [Channels](#channels)\n  - [Using With Marionette](#using-with-marionette)\n- [API](#api)\n  - [Radio.Commands](#commands)\n  - [Radio.Requests](#requests)\n  - [Channel](#channel)\n  - [Radio](#radio)\n  - [Top-level API](#top-level-api)\n\n## Getting Started\n\n### Backbone.Events\n\nAnyone who has used Backbone should be quite familiar with Backbone.Events. Backbone.Events is what facilitates\ncommunications between objects in your application. The quintessential example of this is listening in on a\nModel's change event.\n\n```js\n// Listen in on a model's change events\nthis.listenTo(someModel, 'change', myCallback);\n\n// Later on, the model triggers a change event when it has been changed\nsomeModel.trigger('change');\n```\n\nLet's look at a diagram for Backbone.Events:\n\n<p align='center'>\n  <img src='https://i.cloudup.com/u9oC3S1LxE.svg' alt='Backbone.Events diagram'>\n</p>\n\nIt goes without saying that Backbone.Events is incredibly useful when you mix it into instances of Classes. But what\nif you had a standalone Object with an instance of Backbone.Events on it? This gives you a powerful message bus to utilize.\n\n```js\n// Create a message bus\nvar myBus = _.extend({}, Backbone.Events);\n\n// Listen in on the message bus\nthis.listenTo(myBus, 'some:event', myCallback);\n\n// Trigger an event on the bus\nmyBus.trigger('some:event');\n```\n\nThis is the first principle of Backbone.Radio: building a message bus out of Backbone.Events is useful. But before we go more\ninto that, let's look at the two other messaging systems of Backbone.Radio.\n\n### Backbone.Radio.Commands\n\nCommands is similar to Backbone.Events in many ways. You can mix it into your objects, or use it as a standalone message\nbus.\n\n```js\n// You should be familiar with attaching Backbone.Events to an object...\n_.extend(myObj, Backbone.Events);\n\n// Well, attaching Commands is identical\n_.extend(myObj, Backbone.Radio.Commands);\n```\n\nOnce you've attached Commands to your object your object will now have access to the Commands API.\n\nThe next question, then, is what *are* Commands? Commands are a semantic implementation of Backbone.Events. One of the primary\ndifferences between Backbone.Events and Commands is that Commands have **intent**, whereas Events do not. For example, when a model triggers its\nchange event, it has no goal in mind. Instead, the listeners of that event decide what to do with that information. Commands are different.\nYou fire a Command when you do have a goal in mind. And to be even more specific, you fire a Command when you want another object to perform a\nparticular task.\n\n```js\n// Set up a view to comply with a command\nmyView.comply('render', myView.render);\n\n// Causes the view to render\nmyView.command('render');\n```\n\nCommands have a few other things that make it distinct from Backbone.Events. First, you can only register one 'listener' at a time, unlike\nBackbone.Events where there can be many listeners for each trigger. Instead, Commands is a one-to-one relationship. Another difference is that\nno information is returned from the executed callback. This is also unlike Events, where information can travel from the triggerer to its listeners.\n\nThe following diagram illustrates the Commands pattern:\n\n<p align='center'>\n  <img src='https://i.cloudup.com/7e9M5rKFOr.svg' alt='Backbone.Commands diagram'>\n</p>\n\nYou might ask yourself, 'Now why in the world would I fire the command when I can\njust call the method directly?' The answer is that you wouldn't. I only meant for the above example to be used as a means to familiarize yourself\nwith the way Commands works. The real utility of Commands comes when it is used in an independent message bus. But more on that later – let's\nfirst look at Requests.\n\n### Backbone.Radio.Requests\n\nRequests is the last piece of Backbone.Radio. You use it just like Events and Commands: mix it into an object.\n\n```js\n_.extend(myObj, Backbone.Radio.Requests);\n```\n\nRequests share more similarities to Commands than they do Events. They are semantic, by which I mean that there is an intention when making a\nrequest. Of course, the intent here is that you are asking for information to be returned. Just like Commands, requests have a one-to-one system;\nyou can't have multiple 'listeners' to the triggerer.\n\nLet's look at a basic example.\n\n```js\n// Set up an object to reply to a request. In this case, whether or not its visible.\nmyView.reply('visible', this.isVisible);\n\n// Get whether it's visible or not.\nvar isViewVisible = myView.request('visible');\n```\n\nThe handler in `reply` can either return a flat value, like `true` or `false`, or a function to be executed. Either way, the value is sent back to\nthe requester.\n\nHere's a diagram of the Requests pattern:\n\n<p align='center'>\n  <img src='https://i.cloudup.com/tEVU_tuRIX.svg' alt='Backbone.Requests diagram'>\n</p>\n\n### Channels\n\nThe real draw of Backbone.Radio are channels. A Channel is simply an object that has Backbone.Events, Radio.Commands, and Radio.Requests mixed into it;\nit's a standalone message bus comprised of all three systems.\n\nGetting a handle of a Channel is easy.\n\n```js\n// Get a reference to the channel named 'user'\nvar userChannel = Backbone.Radio.channel('user');\n```\n\nOnce you've got a channel, you can attach handlers to it.\n\n```js\nuserChannel.on('some:event', function() {\n  console.log('An event has happened!');\n});\n\nuserChannel.comply('some:action', function() {\n  console.log('I was told to execute some action');\n});\n\nuserChannel.reply('some:request', 'food is good');\n```\n\nYou can also use the 'trigger' methods on the Channel.\n\n```js\nuserChannel.trigger('some:event');\n\nuserChannel.command('some:command');\n\nuserChannel.request('some:request');\n```\n\nYou can have as many channels as you'd like\n\n```js\n// Maybe you have a channel for the profile section of your app\nvar profileChannel = Backbone.Radio.channel('profile');\n\n// And another one for settings\nvar settingsChannel = Backbone.Radio.channel('settings');\n```\n\nThe whole point of Channels is that they provide a way to explicitly namespace events in your application. It gives you greater\ncontrol over which objects are able to talk to one another.\n\nIf you're having difficulty remembering the API of Channels here's a useful mnemonic for you.\n\nEvents is the API that you know; `on`, `off`, `stopListening` and so on. Commands, which starts with a C, only\nuses verbs that start with C: `command`, `comply`, `stopComplying`. And lastly, Requests, which starts with an R,\nonly uses verbs that start with R: `request`, `reply`, and so on.\n\n### Using With Marionette\n\n[Marionette](https://github.com/marionettejs/backbone.marionette) does not use Radio by default, although it will in the next major release: v3. However, you can use Radio today by including a small shim after you load Marionette, but before you load your application's code. To get the shim, refer to [this Gist](https://gist.github.com/jmeas/7992474cdb1c5672d88b).\n\n## API\n\nLike Backbone.Events, **all** of the following methods support both the object-syntax and space-separated syntax. For the sake of brevity,\nI only provide examples for these alternate syntaxes in the most common use cases.\n\n### Commands\n\n#### `command( commandName [, args...] )`\n\nOrder a command to be completed. Optionally pass arguments to send along to the callback. Like Backbone.Event's `trigger` method,\nthis method returns the instance of Commands.\n\nYou can order multiple commands at once by using the space-separated syntax.\n\n```js\nmyChannel.command('commandOne commandTwo');\n```\n\nThis method always returns `undefined`.\n\n#### `comply( commandName, callback [, context] )`\n\nRegister a handler for `commandName` on this object. `callback` will be executed whenever the command is run. Optionally\npass a `context` for the callback, defaulting to `this`.\n\nTo register a default handler for Commands use the `default` commandName. The unhandled `commandName` will be passed as the first argument.\n\n```js\nmyChannel.comply('default', function(commandName) {\n  console.log('No handler was found for this command: ' + commandName);\n});\n\n// This will be handled by the default handler\nmyChannel.command('someUnhandledCommand');\n```\n\nTo register multiple commands at once you may also pass in a hash.\n\n```js\n// Connect all of the commands at once\nmyChannel.comply({\n  'some:command': myCallback,\n  'some:other:command': someOtherCallback\n}, context);\n```\n\nReturns the instance of Commands.\n\n#### `complyOnce( commandName, callback [, context] )`\n\nRegister a handler for `commandName` that only executes a single time.\n\nLike `comply`, you may also pass a hash of commands to register many at once. Refer to the `comply` documentation above\nfor an example.\n\nReturns the instance of Commands.\n\n#### `stopComplying( [commandName] [, callback] [, context] )`\n\nIf `context` is passed, then all handlers with that context will be removed from the object. If `callback` is\npassed then all handlers with that callback will be removed. If `commandName` is passed then this method will\nremove that handler. If no arguments are passed then all handlers are removed from the object.\n\nYou may also pass a hash of commands or space-separated list to remove many commands at once. Refer to the `comply` documentation above\nfor an example.\n\nReturns the instance of Commands.\n\n### Requests\n\n#### `request( requestName [, args...] )`\n\nMake a request for `requestName`. Optionally pass arguments to send along to the callback. Returns the reply, if one\nexists. If there is no reply registered then `undefined` will be returned.\n\nYou can make multiple requests at once by using the space-separated syntax.\n\n```js\nmyChannel.request('commandOne commandTwo');\n```\n\nWhen using the space-separated syntax, the responses will be returned to you as an array.\n\n#### `reply( requestName, callback [, context] )`\n\nRegister a handler for `requestName` on this object. `callback` will be executed whenever the request is made. Optionally\npass a `context` for the callback, defaulting to `this`.\n\nTo register a default handler for Requests use the `default` requestName. The unhandled `requestName` will be passed as the first argument.\n\n```js\nmyChannel.reply('default', function(requestName) {\n  console.log('No reply exists for this request: ' + requestName);\n});\n\n// This will be handled by the default request\nmyChannel.request('someUnhandledRequest');\n```\n\nTo register multiple requests at once you may also pass in a hash.\n\n```js\n// Connect all of the replies at once\nmyChannel.reply({\n  'some:request': myCallback,\n  'some:other:request': someOtherCallback\n}, context);\n```\n\nReturns the instance of Requests.\n\n#### `replyOnce( requestName, callback [, context] )`\n\nRegister a handler for `requestName` that will only be called a single time.\n\nLike `reply`, you may also pass a hash of replies to register many at once. Refer to the `reply` documentation above\nfor an example.\n\nReturns the instance of Requests.\n\n#### `stopReplying( [requestName] [, callback] [, context] )`\n\nIf `context` is passed, then all replies with that context will be removed from the object. If `callback` is\npassed then all requests with that callback will be removed. If `requestName` is passed then this method will\nremove that reply. If no arguments are passed then all replies are removed from the object.\n\nYou may also pass a hash of replies or space-separated replies to remove many at once.\n\nReturns the instance of Requests.\n\n### Channel\n\n#### `channelName`\n\nThe name of the channel.\n\n#### `reset()`\n\nDestroy all handlers from Backbone.Events, Radio.Commands, and Radio.Requests from the channel. Returns the channel.\n\n### Radio\n\n#### `channel( channelName )`\n\nGet a reference to a channel by name. If a name is not provided an Error will be thrown.\n\n```js\nvar authChannel = Backbone.Radio.channel('auth');\n```\n\n#### `DEBUG`\n\nThis is a Boolean property. Setting it to `true` will cause console warnings to be issued\nwhenever you interact with a `request` or `command` that isn't registered. This is useful in development when you want to\nensure that you've got your event names in order.\n\n```js\n// Turn on debug mode\nBackbone.Radio.DEBUG = true;\n\n// This will log a warning to the console if it goes unhandled\nmyChannel.command('show:view');\n\n// Likewise, this will too, helping to prevent memory leaks\nmyChannel.stopReplying('startTime');\n```\n\n#### `tuneIn( channelName )`\n\nTuning into a Channel is another useful tool for debugging. It passes all\ntriggers, commands, and requests made on the channel to\n\n[`Radio.log`](https://github.com/jmeas/backbone.radio#log-channelname-eventname--args-).\nReturns `Backbone.Radio`.\n\n```js\nBackbone.Radio.tuneIn('calendar');\n```\n\n#### `tuneOut( channelName )`\n\nOnce you're done tuning in you can call `tuneOut` to stop the logging. Returns `Backbone.Radio`.\n\n```js\nBackbone.Radio.tuneOut('calendar');\n```\n\n#### `log( channelName, eventName [, args...] )`\n\nWhen tuned into a Channel, this method will be called for all activity on\na channel. The default implementation is to `console.log` the following message:\n\n```js\n'[channelName] \"eventName\" args1 arg2 arg3...'\n```\n\nwhere args are all of the arguments passed with the message. It is exposed so that you\nmay overwrite it with your own logging message if you wish.\n\n### 'Top-level' API\n\nIf you'd like to execute a method on a channel, yet you don't need to keep a handle of the channel around, you can do so with the proxy\nfunctions directly on the `Backbone.Radio` object.\n\n```js\n// Trigger 'some:event' on the settings channel\nBackbone.Radio.trigger('settings', 'some:event');\n```\n\nAll of the methods for all three messaging systems are available from the top-level API.\n",
  "readmeFilename": "README.md",
  "_id": "backbone.radio@0.8.5",
  "_shasum": "dd78fd4f17f75ecdcabecc825c19bf445cdac493",
  "_from": "backbone.radio@^0.8.3",
  "_resolved": "https://registry.npmjs.org/backbone.radio/-/backbone.radio-0.8.5.tgz"
}
